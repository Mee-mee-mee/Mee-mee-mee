import { Injectable } from '@nestjs/common';
import { Oracle } from '../common/database/oracle';
import { queries } from "./task.qFactory";
import { reformatDates } from '../common/utils/common_util';

@Injectable()
export default class taskrepo {
    constructor(private oraUtil: Oracle) { }

    async pmSData(pmHeaderId) {
        try {
            // Fetch the pmtasks and header data
            const query = queries.getTestById;
            const qParams = [pmHeaderId];
            let pmData: any = await this.oraUtil.executeQuery(query, qParams);
            pmData = pmData.rows;

            const query1 = queries.getestById;
            let headerData1: any = await this.oraUtil.executeQuery(query1, qParams);


            // For each task, fetch the availablestatuses
            const statusQuery = queries.getTestbyId;
            const statusParams = [pmHeaderId];
            let statusData: any = await this.oraUtil.executeQuery(statusQuery, statusParams);
            const statusArray = statusData.rows.map(row => row.STATUS_ID);
            for (let task of pmData) {
                // reformatting the date from DB
                task['META_LASTUPDATEDATE'] = reformatDates(task['META_LASTUPDATEDATE']);
                task['STATUSTIMESTAMP'] = reformatDates(task['STATUSTIMESTAMP']);
                if(task['COMMENTS']===null){
                    task['COMMENTS']="";
                }

                if(task['WIDGETID']!==undefined){
                    task['WIDGETID'] = String(task['WIDGETID']);
                }
                
                if(global.usersList && 
                    task['STATUSIDSTAMP'] &&
                    global.usersList[task['STATUSIDSTAMP'].toUpperCase()])
                    {
                    const user = global.usersList[task['STATUSIDSTAMP'].toUpperCase()];
                    task['STATUSIDSTAMP'] = user.lname + ", " + user.fname
                    }

                // Attach availablestatuses to each task
                task.availablestatuses = statusArray;
                if (task['CFD_HELPTEXT_CONVERTED']) {
                    task['CFD_HELPTEXT_CONVERTED'] = this.convertLinksToAnchor(task['CFD_HELPTEXT_CONVERTED']);
                }
            }

            return {
                headerData: headerData1.rows,
                pmtasks: pmData
            };
        } catch (error) {
            throw error;
        }
        
    }
    private convertLinksToAnchor(helptext: string): string {
        helptext= helptext.replace(
            /\[\[LINK:(.*?)\]\](.*?)\[\[\/?\\?LINK\]\]/g,
            (match, url, text) => 
                `<a href="${url}" target="_blank" title="Link to '${url}'">${text}</a>`
        );
        helptext = helptext.replace(/\s*Ã‚\s*/g,'');
        return helptext;
    }
}



+++++++++++++++
import { Test, TestingModule } from '@nestjs/testing';
import taskrepo from './taskrepo';
import { Oracle } from '../common/database/oracle';
import { reformatDates } from '../common/utils/common_util';

jest.mock('../common/database/oracle');
jest.mock('../common/utils/common_util');

describe('taskrepo', () => {
  let repo: taskrepo;
  let oraUtil: Oracle;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [taskrepo, Oracle],
    }).compile();

    repo = module.get<taskrepo>(taskrepo);
    oraUtil = module.get<Oracle>(Oracle);
  });

  it('should be defined', () => {
    expect(repo).toBeDefined();
  });

  describe('pmSData', () => {
    it('should return formatted data when data is fetched successfully', async () => {
      // Mock data
      const mockPmData = {
        rows: [
          {
            META_LASTUPDATEDATE: '2021-01-01',
            STATUSTIMESTAMP: '2021-01-01',
            COMMENTS: null,
            WIDGETID: 123,
            STATUSIDSTAMP: 'user123',
            CFD_HELPTEXT_CONVERTED: '[[LINK:https://example.com]]Example Link[[/LINK]]',
          },
        ],
      };

      const mockHeaderData = {
        rows: [
          {
            headerField1: 'value1',
            headerField2: 'value2',
          },
        ],
      };

      const mockStatusData = {
        rows: [
          { STATUS_ID: 'status1' },
          { STATUS_ID: 'status2' },
        ],
      };

      jest.spyOn(oraUtil, 'executeQuery')
        .mockResolvedValueOnce(mockPmData) // For pmData
        .mockResolvedValueOnce(mockHeaderData) // For headerData1
        .mockResolvedValueOnce(mockStatusData); // For statusData

      // Mock the reformatDates function
      jest.spyOn(reformatDates, 'reformatDates').mockReturnValue('2021-01-01');

      const result = await repo.pmSData('pmHeaderId');

      // Assertions
      expect(result).toEqual({
        headerData: mockHeaderData.rows,
        pmtasks: [
          {
            META_LASTUPDATEDATE: '2021-01-01',
            STATUSTIMESTAMP: '2021-01-01',
            COMMENTS: '',
            WIDGETID: '123',
            STATUSIDSTAMP: 'user123',
            availablestatuses: ['status1', 'status2'],
            CFD_HELPTEXT_CONVERTED: '<a href="https://example.com" target="_blank" title="Link to \'https://example.com\'">Example Link</a>',
          },
        ],
      });

      expect(oraUtil.executeQuery).toHaveBeenCalledTimes(3);
      expect(oraUtil.executeQuery).toHaveBeenCalledWith(expect.any(String), expect.any(Array));
      expect(reformatDates).toHaveBeenCalledWith('2021-01-01');
    });

    it('should handle empty data gracefully', async () => {
      // Mock empty responses
      const emptyMockData = { rows: [] };
      const mockHeaderData = { rows: [] };
      const mockStatusData = { rows: [] };

      jest.spyOn(oraUtil, 'executeQuery')
        .mockResolvedValueOnce(emptyMockData) // For pmData
        .mockResolvedValueOnce(mockHeaderData) // For headerData1
        .mockResolvedValueOnce(mockStatusData); // For statusData

      const result = await repo.pmSData('pmHeaderId');

      expect(result).toEqual({
        headerData: mockHeaderData.rows,
        pmtasks: [],
      });
    });

    it('should return empty string for COMMENTS if it is null', async () => {
      const mockPmData = {
        rows: [
          {
            COMMENTS: null,
            CFD_HELPTEXT_CONVERTED: '[[LINK:https://example.com]]Example Link[[/LINK]]',
          },
        ],
      };

      const mockHeaderData = { rows: [] };
      const mockStatusData = { rows: [] };

      jest.spyOn(oraUtil, 'executeQuery')
        .mockResolvedValueOnce(mockPmData) // For pmData
        .mockResolvedValueOnce(mockHeaderData) // For headerData1
        .mockResolvedValueOnce(mockStatusData); // For statusData

      const result = await repo.pmSData('pmHeaderId');

      expect(result.pmtasks[0].COMMENTS).toBe('');
    });

    it('should correctly convert CFD_HELPTEXT_CONVERTED to anchor links', async () => {
      const mockPmData = {
        rows: [
          {
            CFD_HELPTEXT_CONVERTED: '[[LINK:https://example.com]]Click here[[/LINK]]',
          },
        ],
      };

      const mockHeaderData = { rows: [] };
      const mockStatusData = { rows: [] };

      jest.spyOn(oraUtil, 'executeQuery')
        .mockResolvedValueOnce(mockPmData) // For pmData
        .mockResolvedValueOnce(mockHeaderData) // For headerData1
        .mockResolvedValueOnce(mockStatusData); // For statusData

      const result = await repo.pmSData('pmHeaderId');

      expect(result.pmtasks[0].CFD_HELPTEXT_CONVERTED).toBe(
        '<a href="https://example.com" target="_blank" title="Link to \'https://example.com\'">Click here</a>'
      );
    });

    it('should handle errors thrown by executeQuery', async () => {
      const errorMessage = 'Database error';
      jest.spyOn(oraUtil, 'executeQuery').mockRejectedValue(new Error(errorMessage));

      await expect(repo.pmSData('pmHeaderId')).rejects.toThrow(errorMessage);
    });
  });

  describe('convertLinksToAnchor', () => {
    it('should convert the links in the helptext to anchor tags', () => {
      const helptext = 'Some text [[LINK:https://example.com]]Click Here[[/LINK]] more text';
      const result = repo['convertLinksToAnchor'](helptext);

      expect(result).toBe(
        'Some text <a href="https://example.com" target="_blank" title="Link to \'https://example.com\'">Click Here</a> more text'
      );
    });

    it('should handle empty helptext', () => {
      const helptext = '';
      const result = repo['convertLinksToAnchor'](helptext);

      expect(result).toBe('');
    });

    it('should handle helptext without links', () => {
      const helptext = 'No links here';
      const result = repo['convertLinksToAnchor'](helptext);

      expect(result).toBe('No links here');
    });

    it('should handle malformed link format gracefully', () => {
      const helptext = 'Some text [[LINK:https://example.comClick Here]] more text';
      const result = repo['convertLinksToAnchor'](helptext);

      expect(result).toBe('Some text [[LINK:https://example.comClick Here]] more text');
    });
  });
});
